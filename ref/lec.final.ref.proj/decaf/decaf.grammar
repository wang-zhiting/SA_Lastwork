//       decaf.grammar
// SableCC grammar for decaf, a subset of Java.
// March 2003,  sdb

Package decaf;

Helpers							// Examples
  letter = ['a'..'z'] | ['A'..'Z'] ;			//   w
  digit =    ['0'..'9'] ;				//   3
  digits =   digit+ ;					// 2040099
  exp  =     ['e' + 'E'] ['+' + '-']? digits;		// E-34
  newline = [10 + 13]   ;
  non_star = [[0..0xffff] - '*'];
  non_slash = [[0..0xffff] - '/'];
  non_star_slash = [[0..0xffff] - ['*' + '/']];


Tokens
  comment1 = '//' [[0..0xffff]-newline]* newline ;
  comment2 = '/*' non_star* '*' (non_star_slash non_star* '*'+)* '/' ;

  space = ' ' | 9 | newline ;		// '\t' (=9) doesn't work?
  clas = 'class' ;	// key words (reserved)
  public = 'public' ;
  static = 'static' ;
  void = 'void' ;
  main = 'main' ;
  string = 'String' ;
  int = 'int' ;	
  float = 'float' ;
  for = 'for' ;
  while = 'while' ;
  if = 'if' ;
  else = 'else' ;
  assign = '=' ;
  compare = '==' | '<' | '>' | '<=' | '>=' | '!=' ;
  plus = '+' ;
  minus = '-' ;
  mult = '*' ;
  div = '/' ;
  l_par = '(' ;
  r_par = ')' ;
  l_brace = '{' ;
  r_brace = '}' ;
  l_bracket = '[' ;
  r_bracket = ']' ;
  comma = ',' ;
  semi = ';' ;
  identifier = letter (letter | digit | '_')* ;
  number  =  (digits '.'? digits? | '.'digits) exp? ;	// 2.043e+5
  misc = [0..0xffff] ;


Ignored Tokens
  comment1, comment2, space;


Productions

  program = 		clas identifier l_brace public static void main l_par 
                	  string l_bracket r_bracket [arg]: identifier r_par 
			  compound_stmt r_brace ;
  type = 	  	  {int} 	int 
			| {float} 	float ;
  declaration = 	type identifier identlist* semi;
  identlist =		comma identifier ;

//////////////////////////////////////////////
// Adapted from Appel, Java version, 2nd ed.
//   to eliminate shift-reduce conflict resulting from dangling else.
// yacc seems to work ok despite the conflict (default is to shift, which works),
// Recursive descent also works fine despite the conflict (and ambiguity).
// SableCC will not generate code if there is a conflict.
// That is the reason for the "short-if" constructs below.
//////////////////////////////////////////////
  stmt = 		  {dcl}			declaration
			| {stmt_no_trlr} 	stmt_no_trailer
			| {if_st}		if_stmt
			| {if_else_st}		if_else_stmt
			| {while_st}		while_stmt
			| {for_st}		for_stmt
			;
  stmt_no_short_if =	  {stmt_no_trlr}	stmt_no_trailer
			| {if_else_no_short}	if_else_stmt_no_short_if
			| {while_no_short}	while_stmt_no_short_if
			| {for_no_short}	for_stmt_no_short_if
			;
  stmt_no_trailer =	  {compound} 	compound_stmt
			| {null}	semi
			| {assign}	assign_stmt
			;

  assign_stmt = 	assign_expr semi ;

  for_stmt = 			for l_par assign_expr? semi bool_expr? 
				  [s2]: semi [a2]: assign_expr? r_par stmt ;
  for_stmt_no_short_if =	for l_par assign_expr? semi bool_expr? 
				  [s2]: semi [a2]: assign_expr? r_par stmt_no_short_if ;

  while_stmt =			while l_par bool_expr r_par stmt ;
  while_stmt_no_short_if =	while l_par bool_expr r_par stmt_no_short_if ;

  if_stmt =			if l_par bool_expr r_par stmt ;
  if_else_stmt =		if l_par bool_expr r_par stmt_no_short_if else stmt ;
  if_else_stmt_no_short_if =	if l_par bool_expr r_par [if1]: stmt_no_short_if 
				  else [if2]: stmt_no_short_if ;
 
  compound_stmt =  l_brace stmt* r_brace ;
 
  bool_expr = 	expr compare [right]: expr ;

  expr = 	  {assn} assign_expr 
		| {rval} rvalue 
		;
  assign_expr =	identifier assign expr ;
  rvalue =	  {plus}  rvalue plus term
		| {minus} rvalue minus term
		| {term}  term 
		;
  term = 	  {mult}  term mult factor
		| {div}   term div factor
		| {fac}   factor 
		;
  factor = 	  {pars}   l_par expr r_par
		| {uplus}  plus factor
		| {uminus} minus factor
		| {id}     identifier
		| {num}    number 
		;
